{"version":3,"file":"static/js/618.7226bb20.chunk.js","mappings":"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","sources":["experiment-tracking/components/runs-compare/charts/ParallelCoordinatesPlot.tsx"],"sourcesContent":["import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { Skeleton } from '@databricks/design-system';\nimport Parcoords from 'parcoord-es';\nimport 'parcoord-es/dist/parcoords.css';\nimport { scaleLinear } from 'd3-scale';\nimport { useDynamicPlotSize, truncateString } from './CompareRunsCharts.common';\nimport './ParallelCoordinatesPlot.css';\n\nconst COLOR_BAR_LOWER = '#3182bd';\nconst COLOR_BAR_UPPER = '#f33';\n\n/**\n * Attaches custom tooltip to the axis label inside SVG\n */\nconst attachCustomTooltip = (toolTipClass: string, labelText: string, targetLabel: Element) => {\n  const tooltipPadding = 4;\n  const svgNS = 'http://www.w3.org/2000/svg';\n  const tooltipGroup = document.createElementNS(svgNS, 'g');\n  const newRect = document.createElementNS(svgNS, 'rect');\n  const newText = document.createElementNS(svgNS, 'text');\n  newText.innerHTML = labelText;\n  newText.setAttribute('fill', 'black');\n  tooltipGroup.classList.add(toolTipClass);\n  tooltipGroup.appendChild(newRect);\n  tooltipGroup.appendChild(newText);\n  targetLabel.parentNode?.insertBefore(tooltipGroup, targetLabel.nextSibling);\n\n  const textBBox = newText.getBBox();\n\n  newRect.setAttribute('x', (textBBox.x - tooltipPadding).toString());\n  newRect.setAttribute('y', (textBBox.y - tooltipPadding).toString());\n  newRect.setAttribute('width', (textBBox.width + 2 * tooltipPadding).toString());\n  newRect.setAttribute('height', (textBBox.height + 2 * tooltipPadding).toString());\n  newRect.setAttribute('fill', 'white');\n};\n\nconst ParallelCoordinatesPlotImpl = (props: {\n  data: any;\n  metricKey: string;\n  selectedParams: string[];\n  selectedMetrics: string[];\n  onHover: (runUuid?: string) => void;\n  onUnhover: () => void;\n  closeContextMenu: () => void;\n  width: number;\n  height: number;\n  axesRotateThreshold: number;\n  selectedRunUuid: string | null;\n}) => {\n  // De-structure props here so they will be easily used\n  // as hook dependencies later on\n  const {\n    onHover,\n    onUnhover,\n    selectedRunUuid,\n    data,\n    axesRotateThreshold,\n    selectedMetrics,\n    selectedParams,\n    width: chartWidth,\n    height: chartHeight,\n    closeContextMenu,\n  } = props;\n  const chartRef = useRef<HTMLDivElement>(null);\n  const parcoord: any = useRef<null>();\n\n  // Keep the state of the actually hovered run internally\n  const [hoveredRunUuid, setHoveredRunUuid] = useState('');\n\n  // Basing on the stateful hovered run uuid, call tooltip-related callbacks\n  useEffect(() => {\n    if (hoveredRunUuid) {\n      onHover?.(hoveredRunUuid);\n    } else {\n      onUnhover?.();\n    }\n  }, [hoveredRunUuid, onHover, onUnhover]);\n\n  // Memoize this function so it won't cause dependency re-triggers\n  const getActiveData = useCallback(() => {\n    if (parcoord.current.brushed() !== false) return parcoord.current.brushed();\n    return parcoord.current.data();\n  }, []);\n\n  // Basing on the stateful hovered run uuid and selected run uuid, determine\n  // which runs should be highlighted\n  useEffect(() => {\n    if (!parcoord.current) {\n      return;\n    }\n    // Get immediate active data\n    const activeData = getActiveData();\n\n    // Get all (at most two) runs that are highlighted and/or selected\n    const runsToHighlight = activeData.filter((d: any) =>\n      [hoveredRunUuid, selectedRunUuid].includes(d.uuid),\n    );\n\n    // Either select them or unselect all\n    if (runsToHighlight.length) {\n      parcoord.current.highlight(runsToHighlight);\n    } else {\n      parcoord.current.unhighlight();\n    }\n  }, [hoveredRunUuid, selectedRunUuid, getActiveData]);\n\n  const getClickedLines = useCallback(\n    (mouseLocation: { offsetX: number; offsetY: number }) => {\n      const clicked: [number, number][] = [];\n      const activeData = getActiveData();\n      if (activeData.length === 0) return false;\n\n      const graphCentPts = getCentroids();\n      if (graphCentPts.length === 0) return false;\n\n      // find between which axes the point is\n      const potentialAxeNum: number | boolean = findAxes(mouseLocation, graphCentPts[0]);\n      if (!potentialAxeNum) return false;\n      const axeNum: number = potentialAxeNum;\n\n      graphCentPts.forEach((d: [number, number][], i: string | number) => {\n        if (isOnLine(d[axeNum - 1], d[axeNum], mouseLocation, 2)) {\n          clicked.push(activeData[i]);\n        }\n      });\n\n      return [clicked];\n    },\n    [getActiveData],\n  );\n\n  const highlightLineOnHover = useCallback(\n    (mouseLocation: { offsetX: number; offsetY: number }) => {\n      // compute axes locations\n      const axes_left_bounds: number[] = [];\n      let axes_width = 0;\n      const wrapperElement = chartRef.current;\n\n      if (!wrapperElement) {\n        return;\n      }\n\n      wrapperElement.querySelectorAll('.dimension').forEach(function getAxesBounds(element) {\n        const transformValue = element.getAttribute('transform');\n        // transformValue is a string like \"transform(100)\"\n        if (transformValue) {\n          const parsedTransformValue = parseFloat(transformValue.split('(')[1].split(')')[0]);\n          axes_left_bounds.push(parsedTransformValue);\n          const { width } = (element as SVGGraphicsElement).getBBox();\n          if (axes_width === 0) axes_width = width;\n        }\n      });\n\n      const axes_locations: any[] = [];\n      for (let i = 0; i < axes_left_bounds.length; i++) {\n        axes_locations.push(axes_left_bounds[i] + axes_width / 2);\n      }\n\n      let clicked = [];\n\n      const clickedData = getClickedLines(mouseLocation);\n\n      let foundRunUuid = '';\n      if (clickedData && clickedData[0].length !== 0) {\n        [clicked] = clickedData;\n\n        if (clicked.length > 1) {\n          clicked = [clicked[1]];\n        }\n\n        // check if the mouse is over an axis with tolerance of 10px\n        if (axes_locations.some((x) => Math.abs(x - mouseLocation.offsetX) < 10)) {\n          // We are hovering over axes, do nothing\n        } else {\n          const runData: any = clicked[0];\n          foundRunUuid = runData['uuid'];\n        }\n      }\n      setHoveredRunUuid(foundRunUuid);\n    },\n    [chartRef, getClickedLines],\n  );\n\n  const getCentroids = () => {\n    const margins = parcoord.current.margin();\n    const brushedData = parcoord.current.brushed().length\n      ? parcoord.current.brushed()\n      : parcoord.current.data();\n\n    return brushedData.map((d: any) => {\n      const centroidPoints = parcoord.current.compute_real_centroids(d);\n      return centroidPoints.map((p: any[]) => [p[0] + margins.left, p[1] + margins.top]);\n    });\n  };\n\n  const findAxes = (testPt: { offsetX: number; offsetY: number }, cenPts: string | any[]) => {\n    // finds between which two axis the mouse is\n    const x = testPt.offsetX;\n\n    // make sure it is inside the range of x\n    if (cenPts[0][0] > x) return false;\n    if (cenPts[cenPts.length - 1][0] < x) return false;\n\n    // find between which segment the point is\n    for (let i = 0; i < cenPts.length; i++) {\n      if (cenPts[i][0] > x) return i;\n    }\n    return false;\n  };\n\n  const isOnLine = (\n    startPt: [number, number],\n    endPt: [number, number],\n    testPt: { offsetX: number; offsetY: number },\n    tol: number,\n  ) => {\n    // check if test point is close enough to a line\n    // between startPt and endPt. close enough means smaller than tolerance\n    const x0 = testPt.offsetX;\n    const y0 = testPt.offsetY;\n    const [x1, y1] = startPt;\n    const [x2, y2] = endPt;\n    const Dx = x2 - x1;\n    const Dy = y2 - y1;\n    const delta =\n      Math.abs(Dy * x0 - Dx * y0 - x1 * y2 + x2 * y1) /\n      Math.sqrt(Math.pow(Dx, 2) + Math.pow(Dy, 2));\n    if (delta <= tol) return true;\n    return false;\n  };\n\n  useEffect(() => {\n    if (chartRef !== null) {\n      const num_axes = selectedParams.length + selectedMetrics.length;\n      const axesLabelTruncationThreshold = num_axes > axesRotateThreshold ? 15 : 15;\n      const tickLabelTruncationThreshold = num_axes > axesRotateThreshold ? 9 : 9;\n      const maxAxesLabelWidth = (chartWidth / num_axes) * 0.8;\n      const maxTickLabelWidth = (chartWidth / num_axes) * 0.4;\n\n      // last element of selectedMetrics is the primary metric\n      const metricKey: string = selectedMetrics[selectedMetrics.length - 1];\n      // iterate through runs in data to find max and min of metricKey\n      const metricVals = data.map((run: any) => run[metricKey]);\n      const minValue = Math.min(...metricVals.filter((v: number) => !isNaN(v)));\n      const maxValue = Math.max(...metricVals.filter((v: number) => !isNaN(v)));\n\n      // use d3 scale to map metric values to colors\n      const color_set = scaleLinear<string>()\n        .domain([minValue, maxValue])\n        .range([COLOR_BAR_LOWER, COLOR_BAR_UPPER]);\n\n      const wrapperElement = chartRef.current;\n\n      // clear the existing chart state\n      if (wrapperElement) {\n        wrapperElement.querySelector('#wrapper svg')?.remove();\n      }\n\n      // clear old canvases if they exist\n      if (wrapperElement) {\n        wrapperElement.querySelectorAll('canvas').forEach((canvas) => canvas.remove());\n      }\n      const getAxesTypes = () => {\n        const keys = Object.keys(data[0]);\n        const nonNullValues = keys.map((key) =>\n          data.map((d: any) => d[key]).filter((v: any) => v !== null),\n        );\n        const types = nonNullValues.map((v: any) => {\n          if (v.every((x: any) => !isNaN(x))) return 'number';\n          return 'string';\n        });\n        return Object.fromEntries(keys.map((_, i) => [keys[i], { type: types[i] }]));\n      };\n\n      parcoord.current = Parcoords()(chartRef.current)\n        .width(chartWidth)\n        .height(chartHeight)\n        .data(data)\n        .dimensions(getAxesTypes())\n        .alpha(0.8)\n        .alphaOnBrushed(0.2)\n        .hideAxis(['uuid'])\n        .lineWidth(1)\n        .color((d: any) => {\n          if (d && metricKey in d && d[metricKey] !== 'null') {\n            return color_set(d[metricKey]);\n          } else {\n            return '#f33';\n          }\n        })\n        .createAxes()\n        .render()\n        .reorderable()\n        .brushMode('1D-axes');\n\n      // add hover event\n\n      if (!wrapperElement) {\n        return;\n      }\n\n      // if brushing, clear selected lines\n      parcoord.current.on('brushend', () => {\n        parcoord.current.unhighlight();\n        closeContextMenu();\n      });\n\n      // Add event listeners just once\n      wrapperElement\n        .querySelector('#wrapper svg')\n        ?.addEventListener('mousemove', function mouseMoveHandler(ev: Event) {\n          const { offsetX, offsetY } = ev as MouseEvent;\n          highlightLineOnHover({ offsetX, offsetY });\n        });\n\n      wrapperElement.querySelector('#wrapper svg')?.addEventListener('mouseout', () => {\n        setHoveredRunUuid('');\n      });\n\n      // rotate and truncate axis labels\n      wrapperElement.querySelectorAll('.parcoords .label').forEach((e) => {\n        const originalLabel = e.innerHTML;\n        if (num_axes > axesRotateThreshold) {\n          e.setAttribute('transform', 'rotate(-30)');\n        }\n        e.setAttribute('y', '-20');\n        e.setAttribute('x', '20');\n        const width_pre_truncation = e.getBoundingClientRect().width;\n        if (width_pre_truncation > maxAxesLabelWidth) {\n          e.innerHTML = truncateString(originalLabel, axesLabelTruncationThreshold);\n          if (originalLabel !== e.innerHTML) {\n            attachCustomTooltip('axis-label-tooltip', originalLabel, e);\n          }\n        }\n      });\n\n      // truncate tick labels\n      wrapperElement.querySelectorAll('.parcoords .tick text').forEach((e) => {\n        const originalLabel = e.innerHTML;\n        const width_pre_truncation = e.getBoundingClientRect().width;\n        if (width_pre_truncation > maxTickLabelWidth) {\n          e.innerHTML = truncateString(originalLabel, tickLabelTruncationThreshold);\n          if (originalLabel !== e.innerHTML) {\n            attachCustomTooltip('tick-label-tooltip', originalLabel, e);\n          }\n        }\n      });\n\n      // draw color bar\n      const lg = parcoord.current.svg\n        .append('defs')\n        .append('linearGradient')\n        .attr('id', 'mygrad') // id of the gradient\n        .attr('x1', '0%')\n        .attr('x2', '0%')\n        .attr('y1', '0%')\n        .attr('y2', '100%'); // since its a vertical linear gradient\n      lg.append('stop')\n        .attr('offset', '0%')\n        .style('stop-color', '#f33') // end in red\n        .style('stop-opacity', 1);\n      lg.append('stop')\n        .attr('offset', '100%')\n        .style('stop-color', '#3182bd') // start in blue\n        .style('stop-opacity', 1);\n\n      // place the color bar right after the last axis\n      // D3's select() has a hard time inside shadow DOM, let's use querySelector instead\n      const parcoord_dimensions = chartRef.current?.querySelector('svg')?.getBoundingClientRect();\n      const last_axes = chartRef.current?.querySelector('.dimension:last-of-type');\n      if (!last_axes) return;\n      const last_axes_box = last_axes?.getBoundingClientRect();\n      const last_axes_location = last_axes?.getAttribute('transform');\n      // last_axes_location is a string like \"transform(100)\"\n      if (!last_axes_location) return;\n      const last_axes_location_value = parseFloat(last_axes_location.split('(')[1].split(')')[0]);\n      if (parcoord_dimensions) {\n        const rect = parcoord.current.svg.append('rect');\n        rect\n          .attr('x', last_axes_location_value + 20)\n          .attr('y', 0)\n          .attr('width', 20)\n          .attr('height', last_axes_box.height - 40)\n          .style('fill', 'url(#mygrad)');\n      }\n    }\n  }, [\n    // Don't retrigger this useEffect on the entire props object update, only\n    // on the fields that are actually relevant\n    data,\n    chartWidth,\n    chartHeight,\n    selectedParams,\n    selectedMetrics,\n    onHover,\n    axesRotateThreshold,\n    highlightLineOnHover,\n    chartRef,\n    closeContextMenu,\n  ]);\n\n  return (\n    <div\n      ref={chartRef}\n      id='wrapper'\n      style={{ width: props.width, height: props.height }}\n      className={'parcoords'}\n    />\n  );\n};\n\nexport const ParallelCoordinatesPlot = (props: any) => {\n  const wrapper = useRef<HTMLDivElement>(null);\n\n  const { layoutHeight, layoutWidth, setContainerDiv } = useDynamicPlotSize();\n\n  const [isResizing, setIsResizing] = useState(true);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  useEffect(() => {\n    setContainerDiv(wrapper.current);\n  }, [setContainerDiv]);\n\n  useEffect(() => {\n    setIsResizing(true);\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    timeoutRef.current = setTimeout(() => {\n      setIsResizing(false);\n    }, 300); // Unblock after 300 ms\n  }, [layoutHeight, layoutWidth]);\n\n  return (\n    <div ref={wrapper} css={{ overflow: 'hidden', flex: '1', paddingTop: '20px', fontSize: 0 }}>\n      {isResizing ? (\n        <Skeleton />\n      ) : (\n        <ParallelCoordinatesPlotImpl {...props} width={layoutWidth} height={layoutHeight} />\n      )}\n    </div>\n  );\n};\n\nexport default ParallelCoordinatesPlot;\n"],"names":["attachCustomTooltip","toolTipClass","labelText","targetLabel","svgNS","tooltipGroup","document","createElementNS","newRect","newText","innerHTML","setAttribute","classList","add","appendChild","parentNode","insertBefore","nextSibling","textBBox","getBBox","x","toString","y","width","height","ParallelCoordinatesPlotImpl","props","onHover","onUnhover","selectedRunUuid","data","axesRotateThreshold","selectedMetrics","selectedParams","chartWidth","chartHeight","closeContextMenu","chartRef","useRef","parcoord","hoveredRunUuid","setHoveredRunUuid","useState","useEffect","getActiveData","useCallback","current","brushed","runsToHighlight","filter","d","includes","uuid","length","highlight","unhighlight","getClickedLines","mouseLocation","clicked","activeData","graphCentPts","getCentroids","potentialAxeNum","findAxes","axeNum","forEach","i","isOnLine","push","highlightLineOnHover","axes_left_bounds","axes_width","wrapperElement","querySelectorAll","element","transformValue","getAttribute","parsedTransformValue","parseFloat","split","axes_locations","clickedData","foundRunUuid","some","Math","abs","offsetX","margins","margin","map","compute_real_centroids","p","left","top","testPt","cenPts","startPt","endPt","tol","x0","y0","offsetY","x1","y1","x2","y2","Dx","Dy","sqrt","pow","num_axes","axesLabelTruncationThreshold","tickLabelTruncationThreshold","maxAxesLabelWidth","maxTickLabelWidth","metricKey","metricVals","run","minValue","min","v","isNaN","maxValue","max","color_set","scaleLinear","domain","range","querySelector","remove","canvas","getAxesTypes","keys","Object","types","key","every","fromEntries","_","type","Parcoords","dimensions","alpha","alphaOnBrushed","hideAxis","lineWidth","color","createAxes","render","reorderable","brushMode","on","addEventListener","ev","e","originalLabel","getBoundingClientRect","truncateString","lg","svg","append","attr","style","parcoord_dimensions","last_axes","last_axes_box","last_axes_location","last_axes_location_value","ref","id","className","ParallelCoordinatesPlot","wrapper","layoutHeight","layoutWidth","setContainerDiv","useDynamicPlotSize","isResizing","setIsResizing","timeoutRef","clearTimeout","setTimeout","css"],"sourceRoot":""}